# Git讲义和课堂笔记



说明：

:eight_spoked_asterisk:  了解部分

:fire:  重点部分



### Git的简介（:eight_spoked_asterisk: ）





#### Git是什么

Git是目前世界上最先进的分布式版本控制系统(没有之一)。

那什么是版本控制系统？

如果你用word文档写过长篇大论，那你一定有这样的经历：

想删除一个段落，又怕将来想恢复找不回来怎么办？有办法，先把当前文件“另存为……”一个新的Word文件，再接着改，改到一定程度，再“另存为……”一个新文件，这样一直改下去，最后你的Word文档变成了这样：



![lots-of-docs](https://cdn.liaoxuefeng.com/cdn/files/attachments/0013848606651673ff1c83932d249118bf8fd5c58c15ca2000/0)&nbsp;



过了一周，你想找回被删除的文字，但是已经记不清删除前保存在哪个文件里了，只好一个一个文件去找，真麻烦。

看着一堆乱七八糟的文件，想保留最新的一个，然后把其他的删掉，又怕哪天会用上，还不敢删，真郁闷。

更要命的是，有些部分需要你的财务同事帮助填写，于是你把文件Copy到U盘里给她（也可能通过Email发送一份给她），然后，你继续修改Word文件。一天后，同事再把Word文件传给你，此时，你必须想想，发给她之后到你收到她的文件期间，你作了哪些改动，得把你的改动和她的部分合并，真困难。

于是你想，如果有一个软件，不但能自动帮我记录每次文件的改动，还可以让同事协作编辑，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。如果想查看某次改动，只需要在软件里瞄一眼就可以，岂不是很方便？



#### Git诞生的背景

很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。

Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？

事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！

你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。

不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。

安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。

Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：

Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。

Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。

历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。



#### Git特点



-  适合分布式开发，强调个体； 

-  公共服务器压力和数据量都不会太大；速度快、灵活； 

-  任意两个开发者之间可以很容易的解决冲突；离线工作。 

   

#### Git缺点

-  代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息； 

-  权限控制不友好；如果需要对开发者限制各种权限的建议使用 SVN。 

   


#### 本节小结

-  Git是什么

   Git是开源的分布式版本控制系统

-  Git的特点是

   速度快，灵活，不需要自己搭建公共服务器，开源离线工作。

-  Git的诞生和技术背景

   由linus团队用C语言开发的分布式控制系统。

-  Github的网站地址

   https://www.github.com

   


#### 本节问题

-  什么是分布式的版本控制系统
-  什么是GitHub
-  传统的SVN版本控制和Git的区别和差异是什么。



<div style="text-align:center;background:#eee">
------1---end-------
</div>



### Git和SVN的对比（:eight_spoked_asterisk:）



#### SVN是什么

SVN 是集中式版本控制系统，说集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。

下图就是标准的集中式版本控制工具管理方式： 



![central-repo](https://cdn.liaoxuefeng.com/cdn/files/attachments/001384860735706fd4c70aa2ce24b45a8ade85109b0222b000/0)&nbsp;

<p style="background:#eeeeee;color:red;padding:20px;">集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，这还不得把人给憋死啊。</p>



#### Git分布式版本控制系统

那分布式版本控制系统与集中式版本控制系统有何不同呢？首先，<span style="color:red">分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。</span>既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。

和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。

在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。



![distributed-repo](https://cdn.liaoxuefeng.com/cdn/files/attachments/0013848607465969378d7e6d5e6452d8161cf472f835523000/0)&nbsp;





<p style="color:red;background:#eeeeee;padding:20px;">当然，Git的优势不单是不必联网这么简单，后面我们还会看到Git极其强大的分支管理，把SVN等远远抛在了后面。</p>



#### 版本控制发展史

CVS作为最早的开源而且免费的集中式版本控制系统，直到现在还有不少人在用。由于CVS自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况。同样是开源而且免费的SVN修正了CVS的一些稳定性问题，是目前用得最多的集中式版本库控制系统。

除了免费的外，还有收费的集中式版本控制系统，比如IBM的ClearCase（以前是Rational公司的，被IBM收购了），特点是安装比Windows还大，运行比蜗牛还慢，能用ClearCase的一般是世界500强，他们有个共同的特点是财大气粗，或者人傻钱多。

微软自己也有一个集中式版本控制系统叫VSS，集成在Visual Studio中。由于其反人类的设计，连微软自己都不好意思用了。

分布式版本控制系统除了Git以及促使Git诞生的BitKeeper外，还有类似Git的Mercurial和Bazaar等。这些分布式版本控制系统各有特点，但最快、最简单也最流行的依然是Git！



#### 小结

-  什么是集中式版本控制

   >  集中式版本控制系统最大的毛病就是必须联网才能工作,需要安装公共的服务器进行数据的控制和管理。

-  什么是分布式版本控制

   >分布式版本控制系统：是一种去中心服务器的概念，把版本的控制和管理权限都交给用户自己的电脑，每个人的电脑都是一个完整的版本库。这样就不需要联网，因为操作都是在自己的电脑上，然后通过一系列的命令或者提供的客户端工具来管理。

-  版本控制家族

   -  vss
   -  cvs
   -  clearcase
   -  svn
   -  git



<div style="text-align:center;background:#eee">
------2--end-------
</div>



### Git的工作流程（:fire:）



#### 工作流程



一般工作流程如下： 

1.  从远程仓库中克隆 Git 资源作为本地仓库； 
2.  从本地仓库中 checkout 代码然后进行代码修改； 
3.  在提交本地仓库前先将代码提交到暂存区； 
4.  提交修改，提交到本地仓库；本地仓库中保存修改的各个历史版本； 
5.  在需要和团队成员共享代码时，可以将修改代码 push 到远程仓库。 





 #### Git 的工作流程图



![1550648567784](assets\1550648567784.png)&nbsp;

<div style="text-align:center;background:#eee">
------3--end-------
</div>



### Git的安装(:fire:)

Git 是由 C 语言编写；最早 Git 只能在 Linux 和 Unix 系统上使用。不过慢慢地有人把它移植到了 Windows 上。现在 Git 可以在 Linux、Unix、Mac 和 Windows

这几大平台上正常运行使用。 

#### 软件下载

[https://git](https://git-scm.com/download)[-](https://git-scm.com/download)[scm.com/download](https://git-scm.com/download)

<div style="padding:20px;color:green;background:#eee;">在“资料/git 安装包”中已经下载好 linux 和 windows 版本的安装包；根据自身系统情况选择性安装。</div>

![1550648832291](assets\1550648832291.png)



#### 软件安装



##### 安装 **Git for windows** 

这是 windows 版本的 git 服务器；所以必须安装；安装说明详情见“资料\git 安

装包\windows\Git-2.14.1”下的《Windows 系统安装 Git 2.14.1.docx》。 

##### 安装 **TortoiseGit** 

这是 windows 下对 git 操作的一个图形界面管理工具，安装后可以方便地使用图

形界面去操作 git；安装说明详情见“资料\git 安装包\windows\TortoiseGit-2.5.0.0” 下的《Windows 系统安装 TortoiseGit 2.5.0.0.docx》。 

##### 安装汉化语音包

这是 windows 下对 git 操作的一个图形界面管理工具的一个中文语言包，安装后 TortoiseGit 的菜单就变成中文的了；安装说明详情见“资料\git 安装包\windows\TortoiseGit-2.5.0.0”下的《Windows 系统安装 TortoiseGit-LanguagePack-2.5.0.0.docx》。 



<div style="text-align:center;background:#eee">
------4--end-------
</div>

​    

### Git的使用(:fire:)



#### 目标

*  创建版本库
*  文件的添加上传
*  文件的修改
*  文件的还愿
*  相关文件忽略和排除
*  文件的日志查看
*  文件的删除
*  文件的冲突和解决
*  java工程控制和管理



---



#### :star:创建版本库  

##### 使用gitbash

GitBash 是安装 Git 的时候自带的一个类似 Linux 终端的工具；在该工具上可以通过 git 命令对 git 进行所有操作。使用  GitBash 创建版本库；在任何一个目录下右击，然后点击 “Git Bash Here”

![1550650346470](assets\1550650346470.png)&nbsp;

表示在当前目录下创建一个版本库；实现步骤如下：

1.  通过输入下面命令，会在当前目录生成一个.git的目录。

```java
git init 
git init --bare 
```

![1550650403658](assets\1550650403658.png)&nbsp;



2. 创建完后再到 windows 中查看目录：



   ![1550650479021](assets\1550650479021.png)&nbsp;



通过git init命令会生成一个.git目录，其中包括如下内容：

![img](https://img-blog.csdn.net/20171128121600539?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWF5Zmxh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)&nbsp;

>**hooks****（钩）**：存放一些shell脚本
>
>**Info**：exclude：存放仓库的一些信息
>
>**logs**：保存所有更新的引用记录
>
>**objects**：存放所有的git对象
>
>**refs：**
>
>	heads：保存当前最新的一次提交的哈希值
>	
>	COMMIT_EDITMSG：
>	
>	最新提交的一次Commit Message，git系统不会用到，给用户一个参考
>
>**description**：仓库的描述信息，主要给gitweb等git托管系统使用
>
>**config**：git仓库的配置文件
>
>**index**：暂存区（stage），一个二进制文件
>
>**FETCH_HEAD**： 是一个版本链接，指向着目前已经从远程仓库取下来的分支的末端版本
>
>**HEAD**：映射到ref引用，能够找到下一次commit的前一次哈希值（看上面logs的图）
>
>当更新一个引用时，git不会packed-refs，而是会在refs/heads下写入一个新文件。当查找一个引用时，git首先在refs目录下查找，如果未找到则到packed-refs文件中去查找。



----



##### TortoiseGit创建版本库

实现步骤如下：

1: 在任意没有创建过版本库的目录下点击右键菜单选择：【“git在这里创建版本”】

>  ![1550651554818](assets\1550651554818.png)&nbsp;	

2：然后点击【确定】按钮即可

>  ![1550651595081](assets\1550651595081.png)&nbsp;	
>
>  <div style='color:red'>如果勾选了上述的框，那么会将“.git”文件夹里面的内容全部放置到当前目录下，这样如果需要在这个目录也放置项目的话，那么就显得混乱了。 </div>

>  ![1550651804113](assets\1550651804113.png)&nbsp;



3.版本库创建成功，会在当前目录下创建一个.git 的隐藏目录，如下所示： 

>  ![img](assets\clip_image002.jpg)&nbsp; 



##### 小结

>  1: 初始化一个Git仓库，使用`git init`命令。	
>
>  2:也可以通过TortoiseGit来创建仓库。
>
>  3:git init --bare 来创建没有.git的目录版本库，但是不推荐这样做，因为会非常的混乱。



---



#### :star:添加文件 

##### 步骤

1. 在版本库目录中，新建一个 'a.txt'文件【工作区】



   ![1550654046404](assets\1550654046404.png)&nbsp;

2. 通过 **TortoiseGit** 客户端工具，将文件提交【暂存区】



![1550654147565](assets\1550654147565.png)&nbsp;



![1550654167487](assets\1550654167487.png)&nbsp;



添加到暂存区的结果如下：

![1550654186233](assets\1550654186233.png)&nbsp;



3. 点击【提交】按钮，提交到【版本区】


![1550654388099](assets\1550654388099.png)&nbsp;



![1550654400709](assets\1550654400709.png)&nbsp;



![1550654481509](assets\1550654481509.png)&nbsp;



提交到本地仓库完成： 

​						![1550654495873](assets\1550654495873.png)&nbsp;&nbsp;   



##### 工作区，暂存区，版本区是什么

Git 和其他版本控制系统如 SVN 的一个不同之处就是有暂存区的概念。 

>  什么是工作区（**Working Directory**）？ 

工作区就是在电脑上能看到的目录，比如上述例子中的“git2”文件夹就是一个工作区。其实 git2 目录是工作区，在这个目录中的“.git”隐藏文件夹才是版本库。 

>  Git 的版本库里存了很多东西，其中最重要的就是称为 stage（或者叫 index）的暂存区，

还有 Git 自动创建的第一个分支 master，以及指向 master 的一个指针叫 HEAD（指向最新版本的一个指针）。 



如下图所示： 

![img](http://img.blog.csdn.net/20151030110206984?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center) 



##### 小结

>  添加文件的流程命令有哪些：

```java
> git status  查看文件提交之前的状态
> git add .   注意这里有一个点。代表提交所有文件到暂存区中
> git status  在此查看状态，观察文件的颜色变化
> git commit -m '注释....'  将暂存区中的代码提交到版本区，行为历史版本
> git log 查看整个文件提交的日志情况。
```

>  熟悉GIT的三个区设计的意义和目的，以及和svn的设计的不同之处。

 

---



#### :star:修改文件

##### 提交修改



>  修改a.txt文件。提交代码带版本库中即可

![1550655627941](assets\1550655627941.png)&nbsp;





点击 “Git提交(C)->”master”… ” 后续的操作与添加文件一样。

或者通过命令：

```java
git commit -m '注释....'
```





##### 查看修改历史

在开发过程中可能会经常查看代码的修改历史，或者叫做查看代码的修改日志。用来查看某个版本是谁修改的，什么时间修改的，修改了哪些内容。可以在文件上点击右键选择“显示日志”来查看文件的修改历史。



![1550655786573](assets\1550655786573.png)&nbsp;





![1550655828997](assets\1550655828997.png)&nbsp;





##### 差异比较

当文件内容修改后，需要和修改之前对比一下修改了哪些内容此时可以使用

“比较差异功能”。 

![1550656417473](assets\1550656417473.png)&nbsp;

![1550656422544](assets\1550656422544.png)&nbsp;





##### 还原比较

当文件修改后不想把修改的内容提交，还想还原到未修改之前的状态。此时可以使用“还原”功能。 



![1550656450327](assets\1550656450327.png)&nbsp;



![1550656456315](assets\1550656456315.png)&nbsp;

![1550656461903](assets\1550656461903.png)&nbsp;



<p style="color:red">【注意】：还原之后，对原来文件的还未提交的修改就不见了；所以在做还原之前要考虑清楚，要么备份好。 </p>



---



#### :star:删除文件

在工作区中先将文件删除；然后需要同样删除版本库中的文件的话，需要提交删除到版本库。 

![1550656735195](assets\1550656735195.png)&nbsp;



提交删除到版本库： 

![1550656747510](assets\1550656747510.png)&nbsp;



![1550656754085](assets\1550656754085.png)&nbsp;



##### 小结

你也可以通过命令的方式进行操作：

```java
> git status 查看状态
> git add test.txt
> git commit -m 'add test.txt'
> git status 查看状态
> rm test.txt 删除文件 
> git rm test.txt 文件
> git commit -m 'delete test.txt'
> git status
```



---



#### :star:添加Java工程到本地仓库

##### 步骤

1. 创建 java 工程，复制工程到工作目录中； 

   ![1550674409759](assets\1550674409759.png)&nbsp;

2. 将工程中的不必要的文件忽略； 

   在此工程中，并不是所有文件都需要保存到版本库中的例如“target”目录及目录下的文件就可以忽略。在 Git 工作区的根目录下创建一个特殊的.gitignore 文

   件，然后把要忽略的文件名填进去，Git 就会自动忽略这些文件或目录。 

   如果使用 TortoiseGit 的话可以使用菜单项直接进行忽略。 

   ![1550674430053](assets\1550674430053.png)&nbsp;

   ![1550674449724](assets\1550674449724.png)&nbsp;

   

   

   ![1550674465205](assets\1550674465205.png)&nbsp;

   ![1550674490803](assets\1550674490803.png)&nbsp;

3.   上述的.gitignore 文件里面就是被忽略的文件列表，该文件也是可以编辑的。 

   ![1550674512113](assets\1550674512113.png)&nbsp;

4.  将工程添加到暂存区； 

   ![1550674644133](assets\1550674644133.png)&nbsp;

   

   

   ![1550674653533](assets\1550674653533.png)&nbsp;

   

   

   ![1550674660327](assets\1550674660327.png)&nbsp;

   

5. 提交到版本区

   

   ![1550674672329](assets\1550674672329.png)&nbsp;

   

   ![1550674677207](assets\1550674677207.png)&nbsp;



>  提示 : 你也可以通过下面的命令的方式完成上面的操作：

```
> git status
> git add .
> git commit -m '初始提交工程'
```





---



#### :star:忽略文件语法说明

```java
> 空行或是以 # 开头的行即注释行，将会被忽略。 
> 可以在前面添加正斜杠 / 忽略当前路径文件，但不包括子目录的同名文件。 
> 可以在后面添加正斜杠 / 来忽略文件夹。 
> 可以使用 ! 来否定忽略，即比如在前面用了 *.apk ，然后使用 !a.apk ，则这个 a.apk 不会被忽略。 
> * 用来匹配零个或多个字符，如 *.[oa] 忽略所有以".o"或".a"结尾， *~ 忽略所有以 ~ 结尾的文件（这种文件
> 通常被许多编辑器标记为临时文件）； [] 用来匹配括号内的任一字符，如 [abc] ，也可以在括号内加连接符，如 [0-9] 匹配 0 至9 的数； ? 用来匹配单个字符。  


示例如下： 
# 忽略 .a 文件 
*.a 
# 但不忽略 lib.a, 尽管已经在前面忽略了 .a 文件 
!lib.a 
# 仅在忽略当前目录下的 TODO 文件， 但不包括当前目录的子目录下的 subdir/TODO 
/TODO 
# 忽略 build/ 文件夹下的所有文件 build/ 
# 忽略 doc/notes.txt, 不包括 doc/server/arch.txt doc/*.txt 
# 忽略所有的 .pdf 文件 在 doc/ directory 下的 doc/**/*.pdf 

```



#### :star:小结

*  创建版本库的命令是什么？
*  添加/修改版本库的命令是什么？
*  删除版本库的命令是什么？
*  忽略文件提交的文件是什么？

#### 问题

*  能够共享项目吗？
*  github是什么？



<div style="text-align:center;background:#eee">
------5--end-------
</div>


### 远程仓库(:fire:)

在本地创建了一个 Git 仓库，又想让其他人来协作开发，此时就可以把本地

仓库同步到远程仓库，同时还增加了本地仓库的一个备份。 

常用的远程仓库就是 ：

>  github[：](https://github.com/)<https://github.com/>[ ](https://github.com/)

>  国内知名的远程仓库；如码云：https://gitee.com/ 



#### GitHub远程仓库



###### 注册 GitHub 帐号 

访问 <https://github.com/>[ ](https://github.com/) 然后在该网站上注册一个个人的帐号。注册过程按照GitHub 官网的要求输入注册信息非常快速的也就注册完成了。

![1550713967901](assets\1550713967901.png)&nbsp;

【注意】是否注册 GitHub帐号与我们上课没有关系，后续我们的课程内容也不会将代码提交到 GitHub 上；在这里只是演示给大家看GitHub这个远程仓库的操作。 



###### 创建仓库

在注册帐号后，登录 GitHub 网站；然后创建一个仓库： 

![1550714014889](assets\1550714014889.png)&nbsp;



![1550714025404](assets\1550714025404.png)&nbsp;

![1550714064606](assets\1550714064606.png)&nbsp;





###### 添加文件，修改文件，删除文件



![1550714105919](assets\1550714105919.png)&nbsp;



![1550714137444](assets\1550714137444.png)&nbsp;



提交文件： 

![1550714151377](assets\1550714151377.png)&nbsp;



![1550714163111](assets\1550714163111.png)&nbsp;





修改文件



![1550714179880](assets\1550714179880.png)&nbsp;

点击具体的文件后，可以对该文件进行管理： 

![1550714204161](assets\1550714204161.png)&nbsp;



###### 仓库地址说明和克隆

![1550714249320](assets\1550714249320.png)&nbsp;



Github 支持两种同步方式“https”和“ssh”。如果使用 https 很简单基本不需要配置就可以使用，但是每次提交代码和下载代码时都需要输入用户名和密码。而且如果是公司配置的私有
git 服务器一般不提供 https 方式访问。 



###### SSH协议，免密

本地仓库与 GitHub 推送、拉取、克隆时，需要提供可以做这些操作的凭证给 GitHub 才能进行；若使用的是 SSH 方式，那么需要生成私钥与公钥配合使用的话，那么每次操作都不再需要输入帐号和密码即可。 

GIT 服务器上存储的是公钥，本地存储的是私钥，当 push 本地代码库到远程代码库，服务器会要求出示私钥，并且用出示的私钥和它的公钥配对来完成认证。 

###### 什么是SSH

SSH 是英文 Secure SHell 的简写形式。通过使用 SSH，你可以把所有传输的数据进行加密，这样"中间人"这种攻击方式就不可能实现了，而且也能够防止 DNS 欺骗和 IP 欺骗。 使用 SSH，还有一个额外的好处就是传输的数据是经过压缩的，所以可以加快传输的速度。SSH 有很多功能，它既可以代替 Telnet，又可以为 FTP、Pop、甚至为 PPP 提供一个安全的"通道"。 如果一个用户从本地计算机，使用 SSH 协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。 最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。1995 年，由一位芬兰学者设计了 SSH 协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为 Linux 系统的标准配置。

###### SSH 密钥生成  

在 windows
下可以使用 Git Bash.exe 来生成密钥，可以通过开始菜单或者右键菜单打开 Git Bash；

![1550714810811](assets\1550714810811.png)&nbsp;

git bash 执行命令，生命公钥和私钥；命令: 

```java
ssh-keygen -t rsa 
```

![1550714851407](assets\1550714851407.png)&nbsp;

执行命令完成后,在 window 本地用户.ssh 目录
C:\Users\用户名\.ssh 文件夹下面生成如下名称的公钥和私钥： 

![1550714866262](assets\1550714866262.png)&nbsp;



######  SSH 密钥配置 

需要将刚刚生成的公钥设置到 GitHub 上： 

1、  登录 GitHubt，并打开设置： 

![1550714893211](assets\1550714893211.png)&nbsp;

2、  设置公钥； 

![1550714907999](assets\1550714907999.png)&nbsp;



![1550714920035](assets\1550714920035.png)&nbsp;



###### 克隆远程仓库

克隆远程仓库也就是从远程把仓库复制一份到本地，克隆后会创建一个新的本地仓库。选择一个任意部署仓库的目录，然后克隆远程仓库。 

1. 查找克隆仓库地址

   在 GitHub 上找到要克隆的远程仓库地址： 

   

   ![1550714974283](assets\1550714974283.png)&nbsp;

   

   >如上述的地址 SSH 地址为：git@github.com:liaojianbin/gittest.git

   >  如上述的地址 HTTPS 地址为：https://github.com/liaojianbin/gittest.git 

    

2. 使用 GitBash

   在本地一个新的空目录中，右击打开 Git Bash；然后输入如下命令： 

   <span style="color:red;">git clone **git@github.com:liaojianbin/gittest.git** </span>

   【注意】红色部分为在 github 中地址；请在使用时以你的 github 给出的实际地址为主。 

   ![1550715066474](assets\1550715066474.png)&nbsp;

   

   克隆下来后： 

   ![1550715079275](assets\1550715079275.png)&nbsp;

   

3. 使用 TortoiseGit  克隆项目

   先确认 TortoiseGit 的 SSH 客户端；由于 TortoiseGit 默认使用的 ssh 工具是“PuTTY” git Bash 使用的 ssh 工具是“openSSH”，如果想让 TortoiseGit 也使用刚才生成的

   密钥可以做如下配置： 

   ![1550715210757](assets\1550715210757.png)&nbsp;

   ![1550715229863](assets\1550715229863.png)&nbsp;

   ![1550715245892](assets\1550715245892.png)&nbsp;

   Url：远程仓库的地址 

   推送 URL：远程仓库的地址 

   Putty 密钥：选择刚才生成的密钥中的私钥 

   在一个空目录中右击；选择如下： 

   

   ![1550715272130](assets\1550715272130.png)&nbsp;

   

   ![1550715277878](assets\1550715277878.png)&nbsp;

   

###### 同步获取github仓库更新（下载）

在 GitHub 上修改了 Readme文件内容后；需要同步到本地仓库的话： 分布步骤是：

1：添加一个远程仓库名称为 origin；

```java
git remote add origin git@github.com:liaojianbin/gittest.git 
```

如果出现远程仓库已经存在的问题：

![1550715418961](assets\1550715418961.png)&nbsp;

可以执行如下语句删除原有的远程仓库：

```java
git remote rm origin 
```

2：拉取最新远程仓库中代码；拉取远程仓库origin 的 master 分支的最新代码 

```java
git pull origin master 
```

![1550715470483](assets\1550715470483.png)&nbsp;



###### 同步到Github仓库中(上传)

在本地仓库中右击选择如下： 

![1550715494024](assets\1550715494024.png)&nbsp;



![1550715500780](assets\1550715500780.png)&nbsp;



#### 同步到 GitHub 仓库 

在工作区中添加、修改了文件后，提交到本地仓库，然后可以将本地仓库的修改推送的远程仓库中。 

##### 使用 Git Bash

1、  在工作区中添加文件并提交到暂存区；命令：git add . 

![1550715669360](assets\1550715669360.png)&nbsp;

2、提交到本地仓库； 

命令：git commit -m "创建了文件 a" 

 【说明】-m 提交的日志信息 

![1550715703297](assets\1550715703297.png)&nbsp;

3、推送到远程仓库

```java
> git push -u origin master 
【说明】-u 指定默认远程仓库 origin 
```

![1550715796147](assets\1550715796147.png)&nbsp;

到 GitHub上查看：

![1550715812458](assets\1550715812458.png)&nbsp;



##### 使用TortoiseGit 

1、  创建文件并添加到暂存区； 

![1550715846948](assets\1550715846948.png)&nbsp;

![1550715856516](assets\1550715856516.png)&nbsp;





2、提交到本地仓库；

![1550715881040](assets\1550715881040.png)&nbsp;



![1550715887428](assets\1550715887428.png)&nbsp;



![1550715892914](assets\1550715892914.png)&nbsp;





3、  推送的远程仓库 

![1550715907151](assets\1550715907151.png)&nbsp;



![1550715918284](assets\1550715918284.png)&nbsp;



![1550715923936](assets\1550715923936.png)&nbsp;



#### 自定义私有远程仓库

>远程仓库实际上和本地仓库一样，纯粹为了 7x24 小时开机并交换大家的修改。GitHub 就是一个免费托管开源代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给
>GitHub 交保护费，那就只能自己搭建一台 Git 服务器作为私有仓库使用。 

#####  **搭建** Git **服务器** 

搭建 Git 服务器需要准备一台运行 Linux 的机器，在此使用 CentOS。 

安装 Git 需要的一些依赖组件的安装： 

【注意】因为 yum 安装默认找的源是 CentOS 官网的，下载会比较慢；可以将 yum 源配置为国内的。 

###### 安装yum源

```java
# 1，进入 yum 源配置目录 
> cd /etc/yum.repos.d 
 
# 2，备份系统自带的 yum 源 
> mv CentOS-Base.repo CentOS-Base.repo.bk 
 
# 3，下载 163 网易的 yum 源： 
> wget http://mirrors.163.com/.help/CentOS6-Base-163.repo 
 
# 4，更新完 yum 源后，执行下边命令更新 yum 配置，使操作立即生效 
> yum makecache  

```

###### 安装文件上传下载组件

```java
yum install lrzsz
```

###### 安装Git依赖

```java
yum -y install curl curl-devel zlib-devel openssl-devel perl cpio expat-devel gettextdevel gcc cc 
```

安装Git

```java
# 使用 rz 上传 git 安装源码包  
> cd /usr/local 
> rz 选择“资料/git 安装包/linux/git-2.9.5.tar.gz”文件 
 
# 解压包 
> tar -zvxf git-2.9.5.tar.gz 
 
 
#注意：如果解压的时候出现**时间是未来的，说明我们解压这个包的系统的时间是有问题的；执行如下命令同步即可。 
> ntpdate pool.ntp.org 
#删除，重新解压 
> rm –rf git-2.9.5 
> tar -zvxf git-2.9.5.tar.gz 
 
# 配置安装环境 
> cd git-2.9.5 
> autoconf 
> ./configure 
# 编译 
> make 
# 安装
> make install

```



###### 创建Linux操作用户

创建可以操作 git 仓库的 linux 用户git；这个用户可以克隆、拉取、推送等操作。 

```java
# 添加用户 git 
> useradd git 
 
# 设置/home/git 文件夹操作权限 
> chown git:git /home/git 
 
# 设置密码；输入两次密码，密码随便，两次一样就可以 
> passwd git 

```

###### 创建Git仓库

```java
# 切换到 git 用户，创建仓库 
> su git 
> git --bare init /home/git/mygit 
 
# 修改配置文件，允许提交到 master 分支 
> vim /home/git/mygit/config 
 
# 添加如下代码：  
[receive] 
      denyCurrentBranch = ignore 

```

###### 创建 Linux只读 Git 仓库用户 

创建只可以对 git 仓库读的 linux
用户 gitx；这是我为了教学而加的，目的是让大家在上课时使用这个用户拉取最新代码但不能修改代码。

```java
# 使用 root 用户，添加用户 gitx 
> su root 
> useradd gitx 
 
# 设置/home/git 文件夹其它用户可以读权限，让 gitx 用户可以读 git 用户的
/home/git 文件夹，也就是可以读仓库 
> cd /home 
> chmod o+rx git 
 
# 设置密码；输入两次密码，密码随便，两次一样就可以；这里密码使用 123456 
> passwd gitx 

```

###### 连接 Git 服务器 

```java
使用 SSH 连接操作 git，它的地址格式为：
ssh://linux 用户名@服务器地址:端口号+git 仓库在 linux 中路径。 
 
现在私有的远程仓库可以使用如下两个地址来操作： 
ssh://git@192.168.189.128:22/home/git/mygit 
上面使用的 git 用户可以读写 git 仓库。 
 
任选一个空目录；右击“克隆”，地址可以是上述两个任意一个： 

```

![1550717603473](assets\1550717603473.png)&nbsp;

![1550717615243](assets\1550717615243.png)&nbsp;



ssh://gitx@192.168.189.128:22/home/git/mygit 

上面使用的 gitx 用户可以读 git 仓库。 

 对私有远程仓库的操作和对 GitHub 的操作克隆、拉取、推送类似，不再赘述。 







<div style="text-align:center;background:#eee">
------6--end-------
</div>



### 分支管理(:fire:)

#### 分支

每次的提交 Git 都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在 Git 里这个分支叫主分支，即 master 分支。HEAD 指针严格来说不是指向提交，而是指向 master，master 才是指向提交的。 

一开始的时候，master 分支是一条线，Git 用 master 指向最新的提交，再用

HEAD 指向 master，就能确定当前分支，以及当前分支的提交点： 

![1550676643080](assets\1550676643080.png) 

每次提交，master分支都会向前移动一步，这样随着不断提交，master分支的线也越来越长。 

当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上： 

 ![1550676663118](assets\1550676663118.png)

Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！不过切换到了dev分，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变： 

![1550676670109](assets\1550676670109.png)&nbsp;



假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并： 

 

![1550676677379](assets\1550676677379.png)&nbsp;



所以Git合并分支也很快！就改改指针，工作区内容也不变！ 

合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后就剩下了一条master分支： 

![1550676607817](assets\1550676607817.png)&nbsp;





----



####  TortoiseGit 管理分支 



#### 创建分支 

在本地仓库文件夹中点击右键，然后从菜单中选择“创建分支”： 

 ![1550675693624](assets\1550675693624.png) 



![1550675724719](assets\1550675724719.png)&nbsp;



#### 切换分支



创建完毕后想切换到新分支可以勾选“切换到新分支”选项或者从菜单中选择“切换/检出”来切换分支： 

![1550675832305](assets\1550675832305.png) 

 

![1550675843185](assets\1550675843185.png) 



#### 修改分支内容 

在切换到分支版本后；可以在分支下对分支的内容进行修改。 

![1550675853452](assets\1550675853452.png) 



![1550675874459](assets\1550675874459.png)&nbsp;



![1550675897833](assets\1550675897833.png)&nbsp;



#### 合并分支 

切换回 master 分支；发现其内容是没有任何变化的。若这时需要将 dev 分支下的修改合并到 master 分支；则可如下操作： 

 

1、  切换回 master 分支； 

![1550676015266](assets\1550676015266.png)&nbsp;



 ![1550676072343](assets\1550676072343.png)



2、  合并 dev 分支 

![1550676086658](assets\1550676086658.png)&nbsp;



![1550676102033](assets\1550676102033.png)&nbsp;



这是发现 master 分支下也有了 dev 分支的内容。 

![1550676177997](assets\1550676177997.png)&nbsp;





####  解决冲突 

这时在 master 和 dev 都有 dev.txt 文件；两个分支下都对该文件进行修改，然后产生冲突并解决冲突。具体如下： 

1、  master 分支下修改 dev.txt 并提交； 

![1550676243442](assets\1550676243442.png)&nbsp;



2、  切换到 dev 分支； 

![1550676253499](assets\1550676253499.png)&nbsp;



3、  dev 分支下修改 dev.txt 并提交； 

![1550676266040](assets\1550676266040.png)&nbsp;



4、  切换回 master 分支； 

![1550676279506](assets\1550676279506.png)&nbsp;



5、  master 分支合并 dev 分支，出现冲突； 

![1550676294841](assets\1550676294841.png)&nbsp;

 ![1550676311418](assets\1550676311418.png)

 

6、  解决冲突并提交到 master 分支。 

![1550676324268](assets\1550676324268.png)&nbsp;



![1550676334089](assets\1550676334089.png)&nbsp;

![1550676342376](assets\1550676342376.png)&nbsp;



![1550676355672](assets\1550676355672.png)&nbsp;



<div style="text-align:center;background:#eee">
------7--end-------
</div>


### IDEA操作Git(:fire:)



在磁盘下路径如下： 

![1550717842347](assets\1550717842347.png)&nbsp;

![1550717853637](assets\1550717853637.png)&nbsp;



![1550717862910](assets\1550717862910.png)&nbsp;



![1550717867795](assets\1550717867795.png)&nbsp;

![1550717872045](assets\1550717872045.png)&nbsp;



​	![1550717879295](assets\1550717879295.png)&nbsp;



在磁盘下熔路径如下：

![1550717908654](assets\1550717908654.png)&nbsp;





#### 提交代码到本地仓库 

##### 添加代码并创建本地仓库

![1550718041754](assets\1550718041754.png)&nbsp;



![1550718048639](assets\1550718048639.png)&nbsp;



![1550718052981](assets\1550718052981.png)&nbsp;



#### 设置忽略文件

打开项目的工作区，选中那些需要忽略的文件，将其添加到忽略文件中： 

![1550718058289](assets\1550718058289.png)&nbsp;



![1550718064063](assets\1550718064063.png)&nbsp;

 

在 IDEA 中打开.gitignore 文件；出现如下： 

 ![1550718069905](assets\1550718069905.png)&nbsp;

可以在忽略文件中将 IDEA 的配置文件也忽略； 

 ![1550718075080](assets\1550718075080.png)&nbsp;



![1550718089741](assets\1550718089741.png)&nbsp;



#### 提交到本地仓库 

![1550718098729](assets\1550718098729.png)&nbsp;



![1550718104713](assets\1550718104713.png)&nbsp;





 

#### 推送代码到远程仓库

如果推送的仓库是在远程仓库已经存在的；那么本地仓库需要拉取最新的后再推送。 



 ![1550718115047](assets\1550718115047.png)



![1550718121268](assets\1550718121268.png)&nbsp;



![1550718126838](assets\1550718126838.png)&nbsp;



![1550718131440](assets\1550718131440.png)&nbsp;



![1550718135185](assets\1550718135185.png)&nbsp;





如果以后还有需要向远程仓库推送内容；那么 ctrl + K 

![1550718227606](assets\1550718227606.png)&nbsp;



![1550718231518](assets\1550718231518.png)&nbsp;







#### 拉取远程仓库代码 

当远程仓库那边有修改；本地仓库需要同步的话可以使用如下步骤拉取最新远程仓库代码。 

![1550718238429](assets\1550718238429.png)&nbsp;



![1550718243403](assets\1550718243403.png)&nbsp;





#### 修改远程仓库地址 

如果有其它的远程仓库地址或者修改；可以如下： 

![1550718257901](assets\1550718257901.png)&nbsp;



![1550718271913](assets\1550718271913.png)&nbsp;





#### 克隆/检出代码 

从远程仓库中克隆项目到本地形成本地仓库。 

![1550718277238](assets\1550718277238.png)&nbsp;



![1550718282058](assets\1550718282058.png)&nbsp;



![1550718286015](assets\1550718286015.png)&nbsp;



![1550718290554](assets\1550718290554.png)&nbsp;



![1550718362910](assets\1550718362910.png)&nbsp;





![1550718368045](assets\1550718368045.png)&nbsp;



![1550718372645](assets\1550718372645.png)&nbsp;

![1550718633775](assets\1550718633775.png)&nbsp;



![1550718382459](assets\1550718382459.png)&nbsp;





![1550718388647](assets\1550718388647.png)&nbsp;



![1550718413613](assets\1550718413613.png)&nbsp;



#### 解决冲突 

在项目文件发生冲突都是由于两个仓库中都对同一个文件的某一处修改，以致在某个仓库拉取远程仓库代码的时候 git 无法自动合并时需要人为处理冲突： 

1、  在 mygit2 工程中修改文件内容并推送到远程仓库； 

![1550718418531](assets\1550718418531.png)&nbsp;



![1550718425785](assets\1550718425785.png)&nbsp;





2、  在 idea-git-project 工程修改 pom.xml 并提交到本地仓库； 

![1550718431998](assets\1550718431998.png)&nbsp;



3、  在 idea-git-project 工程拉取远程仓库的代码时候发生冲突； 

![1550718437881](assets\1550718437881.png)&nbsp;



![1550718682441](assets\1550718682441.png)&nbsp;

4、  解决冲突； 

![1550718690773](assets\1550718690773.png)&nbsp;



![1550718733748](assets\1550718733748.png)&nbsp;



![1550718751316](assets\1550718751316.png)&nbsp;





5、  提交本地仓库并推送到远程仓库；ctrl + K

![1550718756896](assets\1550718756896.png)&nbsp;

 

<div style="text-align:center;background:#eee">
------8--end-------
</div>


### 总结










### 学习建议

<div style="font-size:20px;font-weight:bold;padding:50px;background:#eee;text-align:center">古人有一条重要的治学经验，好记性不如烂笔头，勤动口不如勤动手。</div>



### 授课老师

<div style="font-size:20px;font-weight:bold;padding:80px;background:#eee;text-align:center">徐柯老师，微信：15074816437，有什么问题直接联系留言给我。
</div>







































